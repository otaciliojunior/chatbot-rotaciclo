// index.js CORRIGIDO, ATUALIZADO E REATORADO

// For√ßando atualiza√ß√£o para deploy - 21/09
// Importa as bibliotecas que instalamos
const express = require('express');
const axios = require('axios');
const { initializeApp, cert } = require('firebase-admin/app');
const { getFirestore, Timestamp } = require('firebase-admin/firestore');
const cors = require('cors');
require('dotenv').config();

const app = express();
app.use(express.json());

// --- CONFIGURA√á√ÉO DO CORS ---
app.use(cors());

// --- INFORMA√á√ïES DE CONFIGURA√á√ÉO ---
const META_ACCESS_TOKEN = process.env.META_ACCESS_TOKEN;
const VERIFY_TOKEN = process.env.VERIFY_TOKEN;
const PHONE_NUMBER_ID = process.env.PHONE_NUMBER_ID;

// --- INICIALIZA√á√ÉO DO FIREBASE ---
const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT_KEY);
initializeApp({
  credential: cert(serviceAccount)
});
const db = getFirestore();

const PORT = process.env.PORT || 3000;

// --- MENSAGENS CENTRALIZADAS DO BOT ---
const botMessages = {
    // --- GERAL ---
    welcome: "Fala, ciclista! Bem-vindo(a) √† *Rota Ciclo*! üö¥\n\nEstamos testando nosso novo canal de atendimento autom√°tico, que j√° est√° bem avan√ßado e preparado pra te ajudar. A ideia √© aproximar ainda mais voc√™ da nossa loja e criar uma experi√™ncia pr√°tica e agrad√°vel no seu atendimento.\n\nBora come√ßar?",
    invalidOption: "Ops, n√£o entendi essa op√ß√£o ü§î. Tenta clicar em uma das op√ß√µes do menu, beleza?",

    // --- MENU PRINCIPAL ---
    mainMenuHeader: "E a√≠, tudo certo?\n\nAqui √© a *Loja Rota Ciclo*! Valeu demais por falar com a gente üòâ\n\nEscolhe uma das op√ß√µes abaixo pra eu te ajudar mais r√°pido:",

    // --- PRODUTOS ---
    askProductCategory: "Show! Quer dar uma olhada em qu√™?\n\n- Bicicletas üö≤\n- Pe√ßas e Acess√≥rios üîß",
    invalidProductCategory: "Hmm, n√£o saquei. Digita 'Bicicletas' ou 'Pe√ßas e Acess√≥rios' que eu entendo üòâ.",
    askBikeType: "Boa escolha! üö¥ Temos bikes pra todo tipo de rol√™:\n\n- Estrada üõ£Ô∏è\n- MTB (Trilha) üåÑ\n- Passeio üå≥\n\nüëâ Qual voc√™ procura?",
    invalidBikeType: "N√£o entendi o tipo de bike üòÖ. Tenta 'Estrada', 'MTB' ou 'Passeio'.",
    askPartType: "Top! Temos de tudo: c√¢maras, pneus, capacetes, luvas, roupas e muito mais üö¥‚Äç‚ôÇÔ∏è.\n\nMe fala o que voc√™ procura que j√° mostro op√ß√µes.",
    searchPart: (searchTerm) => `Beleza, procurando por *${searchTerm}*... üîé (Essa fun√ß√£o t√° chegando em breve!)\n\nSe quiser, digita 'menu' pra voltar.`,
    bikeListHeader: (bikeType) => `Aqui est√£o as bikes de *${bikeType.toUpperCase()}* que temos agora:\n\n`,
    bikeListItem: (bike) => `üö≤ *${bike.nome}*\nüí∞ Pre√ßo: ${bike.preco}\n\n`,
    bikeListFooter: "Curtiu alguma? Me fala o nome que eu te passo mais detalhes. Ou digita 'menu' pra voltar üòâ.",

    // --- AGENDAMENTO ---
    askServiceType: "Claro! Qual servi√ßo voc√™ quer agendar?\n\n- Revis√£o completa üîß\n- Manuten√ß√£o corretiva ‚öôÔ∏è",
    invalidServiceType: "N√£o entendi o servi√ßo üòÖ. Pode ser 'Revis√£o' ou 'Manuten√ß√£o'.",
    listAvailableDays: (serviceType, availableDays) => `Show! Pra *${serviceType}*, temos hor√°rios nos dias: ${availableDays}.\n\nQual dia voc√™ prefere?`,
    invalidDay: "Esse dia n√£o t√° dispon√≠vel ou foi digitado errado ü§∑. Escolhe um dos que te passei, beleza?",
    listAvailableTimes: (day, service, availableTimes) => `Fechado! Na *${day}-feira* temos esses hor√°rios para *${service}*:\n\n‚è∞ ${availableTimes}\n\nüëâ Qual te serve melhor?`,
    invalidTime: "Esse hor√°rio n√£o rola üò¨. Escolhe um dos que eu te mostrei.",
    bookingSuccessRegistered: (service, day, time) => `‚úÖ Agendamento confirmado!\n\nSeu servi√ßo de *${service}* ficou marcado para *${day}-feira* √†s *${time}*.\n\nValeu por escolher a Rota Ciclo üö¥‚Äç‚ôÇÔ∏è!`,
    bookingSuccessUnregistered: (service, day, time) => `‚úÖ Agendamento feito!\n\nSeu servi√ßo de *${service}* ficou marcado para *${day}-feira* √†s *${time}*.\n\n‚ö†Ô∏è N√£o consegui registrar no sistema, ent√£o guarda essa mensagem como comprovante.`,

    // --- ATENDIMENTO HUMANO ---
    requestHumanHandoffReason: "Beleza! Pra agilizar, me conta em uma mensagem s√≥ qual √© a sua d√∫vida principal.\n\n_(Obs: n√£o consigo entender √°udios, s√≥ texto ü´±üèΩ‚Äçü´≤üèΩ)_",
    humanRequestSuccess: "Pronto! Sua solicita√ß√£o j√° t√° na fila. Um dos nossos vai falar contigo aqui mesmo, s√≥ aguarda um pouquinho üòâ.",
    humanRequestError: "Deu erro ao registrar sua solicita√ß√£o üòï. Tenta de novo mais tarde ou chama a gente no (84) 98750-4756",

    // --- INFORMA√á√ïES GERAIS ---
    addressAndHours: "üìç *Endere√ßo:* Av. Monsenhor Paiva, n¬∫ 565\nüïí *Hor√°rio:* Seg a S√°b ‚Äì 8h √†s 17h | Dom ‚Äì 7h √†s 12h\nüìû *Telefone:* (84) 98750-4756\n\nPosso te ajudar em mais alguma coisa? üö≤"
};


// --- MEM√ìRIA E BASE DE DADOS ---
const userStates = {};
const database = {
    "estrada": [
        { nome: "Caloi Strada Racing", preco: "R$ 7.500,00" },
        { nome: "Specialized Allez", preco: "R$ 9.200,00" }
    ],
    "mtb": [
        { nome: "Trek Marlin 5", preco: "R$ 4.800,00" },
        { nome: "Oggi Big Wheel 7.2", preco: "R$ 5.500,00" }
    ],
    "passeio": [
        { nome: "Caloi Urbam", preco: "R$ 2.100,00" },
        { nome: "Sense Move", preco: "R$ 2.350,00" }
    ],
    "servicos": {
        "revisao": {
            "segunda": ["09:00", "11:00", "14:00"],
            "terca": ["10:00", "15:00"],
            "quarta": ["09:00", "11:00", "14:00", "16:00"]
        },
        "manutencao": {
            "segunda": ["10:00", "16:00"],
            "terca": ["09:00", "11:00", "14:00"],
            "quarta": ["15:00"]
        }
    }
};

// --- FUN√á√ïES DE BANCO DE DADOS ---
async function salvarAgendamento(userNumber, service, day, time) {
    try {
        const agendamentoRef = db.collection('agendamentos').doc();
        await agendamentoRef.set({
            cliente: userNumber,
            servico: service,
            dia: day,
            horario: time,
            status: 'pendente',
            criadoEm: new Date()
        });
        console.log(`[${userNumber}] Agendamento salvo com sucesso no Firestore! ID: ${agendamentoRef.id}`);
        return true;
    } catch (error) {
        console.error(`[${userNumber}] Erro ao salvar agendamento no Firestore:`, error);
        return false;
    }
}

async function criarSolicitacaoAtendimento(userNumber, userName, motivo) {
    console.log(`[${userNumber}] INICIANDO A FUN√á√ÉO criarSolicitacaoAtendimento...`);
    try {
        const atendimentoRef = db.collection('atendimentos').doc(userNumber);
        const dadosParaSalvar = {
            cliente_id: userNumber,
            cliente_nome: userName,
            status: 'aguardando',
            solicitadoEm: new Date(),
            motivo: motivo
        };
        console.log(`[${userNumber}] Tentando salvar os seguintes dados:`, JSON.stringify(dadosParaSalvar, null, 2));
        await atendimentoRef.set(dadosParaSalvar);
        console.log(`[${userNumber}] SUCESSO! Solicita√ß√£o de atendimento salva no Firestore!`);
        return true;
    } catch (error) {
        console.error(`[${userNumber}] ERRO CR√çTICO ao salvar solicita√ß√£o de atendimento no Firestore:`, error);
        return false;
    }
}

// Rota principal para testar se o servidor est√° no ar
app.get('/', (req, res) => {
    res.send('Chatbot da Loja de Bicicletas est√° no ar!');
});

// ROTA PARA O PAINEL ENVIAR MENSAGENS
app.post('/api/enviar-mensagem', async (req, res) => {
    const { para, texto } = req.body;
    if (!para || !texto) {
        return res.status(400).json({ error: "N√∫mero do destinat√°rio e texto da mensagem s√£o obrigat√≥rios." });
    }
    try {
        await enviarTexto(para, texto);
        res.status(200).json({ success: true, message: "Mensagem enviada com sucesso!" });
    } catch (error) {
        console.error("Falha ao enviar mensagem pelo painel:", error);
        res.status(500).json({ error: "Falha ao enviar mensagem pela API da Meta." });
    }
});

// Rota do Webhook (GET para verifica√ß√£o, POST para receber mensagens)
app.all('/webhook', (req, res) => {
    if (req.method === 'GET') {
        console.log('--- Recebida requisi√ß√£o de VERIFICA√á√ÉO do Webhook ---');
        if (req.query['hub.verify_token'] === VERIFY_TOKEN) {
            console.log('Token de verifica√ß√£o CORRETO.');
            return res.send(req.query['hub.challenge']);
        }
        console.error('Token de verifica√ß√£o INCORRETO.');
        return res.status(403).send('Erro de verifica√ß√£o');
    }

    if (req.method === 'POST') {
        console.log('--- NOVO EVENTO DO WEBHOOK RECEBIDO (POST) ---');
        const data = req.body;
        try {
            if (data.object === 'whatsapp_business_account' && data.entry?.[0]?.changes?.[0]?.value?.messages?.[0]) {
                const messageData = data.entry[0].changes[0].value.messages[0];
                const fromNumber = messageData.from;
                const userName = data.entry[0].changes[0].value.contacts[0].profile.name;
                let messageBody = '';
                if (messageData.type === 'text') {
                    messageBody = messageData.text.body;
                } else if (messageData.type === 'interactive') {
                    const interactiveType = messageData.interactive.type;
                    if (interactiveType === 'button_reply') {
                        messageBody = messageData.interactive.button_reply.title;
                    } else if (interactiveType === 'list_reply') {
                        messageBody = messageData.interactive.list_reply.title;
                    }
                }
                if (messageBody) {
                    console.log(`Mensagem de [${fromNumber} - ${userName}] para nosso sistema: "${messageBody}"`);
                    processarMensagem(fromNumber, userName, messageBody);
                } else {
                     console.log('Tipo de mensagem n√£o suportada. Ignorando.');
                }
            } else {
                console.log('Evento recebido n√£o √© uma mensagem do WhatsApp. Ignorando.');
            }
        } catch (error) {
            console.error('--- ERRO AO PROCESSAR DADOS DO WEBHOOK ---', error);
        }
        return res.status(200).send('OK');
    }
});

// Fun√ß√£o principal que gerencia o fluxo da conversa
async function processarMensagem(userNumber, userName, userMessage) { 
    const msg = userMessage.toLowerCase().trim();
    
    // --- VERIFICA√á√ÉO DE ESTADO PERSISTENTE ---
    let currentState = userStates[userNumber]?.state;

    if (!currentState) {
        try {
            const atendimentoRef = db.collection('atendimentos').doc(userNumber);
            const docSnap = await atendimentoRef.get();
            
            // --- CORRE√á√ÉO DA SINTAXE: de docSnap.exists() para docSnap.exists ---
            if (docSnap.exists && docSnap.data().status === 'em_atendimento') {
                console.log(`[${userNumber}] Estado recuperado do Firestore: HUMAN_HANDOVER`);
                currentState = 'HUMAN_HANDOVER';
                userStates[userNumber] = { state: 'HUMAN_HANDOVER' };
            }
        } catch (error) {
            console.error(`[${userNumber}] Erro ao buscar estado no Firestore:`, error);
        }
    }
    
    currentState = currentState || 'NEW_USER';
    
    console.log(`[${userNumber}] Estado Atual: ${currentState}`);
    console.log(`[${userNumber}] Mensagem Recebida: ${msg}`);

    // Se o usu√°rio estiver em atendimento, salva a mensagem dele no hist√≥rico do chat
    if (currentState === 'HUMAN_HANDOVER') {
        console.log(`[${userNumber}] Usu√°rio em atendimento humano. Encaminhando mensagem para o hist√≥rico.`);
        try {
            const messagesRef = db.collection('atendimentos').doc(userNumber).collection('mensagens');
            await messagesRef.add({
                texto: userMessage,
                origem: 'cliente',
                enviadaEm: Timestamp.now()
            });
            console.log(`[${userNumber}] Mensagem do cliente salva no hist√≥rico.`);
        } catch (error) {
            console.error(`[${userNumber}] Erro ao salvar mensagem do cliente no hist√≥rico:`, error);
        }
        return; // Finaliza o processamento aqui, impedindo o bot de responder
    }

    if (["menu", "voltar", "cancelar"].includes(msg)) {
        delete userStates[userNumber];
        enviarMenuPrincipalComoLista(userNumber);
        return;
    }
    
    switch (currentState) {
        case 'NEW_USER':
            await enviarTexto(userNumber, botMessages.welcome);
            await new Promise(resolve => setTimeout(resolve, 1500));
            enviarMenuPrincipalComoLista(userNumber);
            break;

        case 'AWAITING_CHOICE':
            if (msg.startsWith("ver produtos")) {
                enviarTexto(userNumber, botMessages.askProductCategory);
                userStates[userNumber] = { state: 'AWAITING_PRODUCT_CATEGORY' };
            } else if (msg.startsWith("agendar manuten√ß√£o")) {
                enviarTexto(userNumber, botMessages.askServiceType);
                userStates[userNumber] = { state: 'AWAITING_SERVICE_TYPE' };
            } else if (msg.startsWith("endere√ßo e hor√°rio")) {
                enviarTexto(userNumber, botMessages.addressAndHours);
                enviarMenuPrincipalComoLista(userNumber);
            } else if (msg.startsWith("falar com atendente")) {
                await enviarTexto(userNumber, botMessages.requestHumanHandoffReason);
                userStates[userNumber] = { state: 'AWAITING_HUMAN_REQUEST_REASON' };
            } else {
                enviarTexto(userNumber, botMessages.invalidOption);
                enviarMenuPrincipalComoLista(userNumber);
            }
            break;

        case 'AWAITING_HUMAN_REQUEST_REASON':
            const motivo = userMessage;
            const sucesso = await criarSolicitacaoAtendimento(userNumber, userName, motivo);
            if (sucesso) {
                await enviarTexto(userNumber, botMessages.humanRequestSuccess);
                userStates[userNumber] = { state: 'HUMAN_HANDOVER' };
            } else {
                await enviarTexto(userNumber, botMessages.humanRequestError);
                userStates[userNumber] = { state: 'AWAITING_CHOICE' };
            }
            break;

        case 'AWAITING_PRODUCT_CATEGORY':
            if (msg.includes('bicicletas')) {
                enviarTexto(userNumber, botMessages.askBikeType);
                userStates[userNumber] = { state: 'AWAITING_BIKE_TYPE' };
            } else if (msg.includes('pe√ßas') || msg.includes('acess√≥rios')) {
                enviarTexto(userNumber, botMessages.askPartType);
                userStates[userNumber] = { state: 'AWAITING_PART_TYPE' };
            } else {
                 enviarTexto(userNumber, botMessages.invalidProductCategory);
            }
            break;

        case 'AWAITING_BIKE_TYPE':
            let bikeType = null;
            if (msg.includes('estrada')) bikeType = 'estrada';
            if (msg.includes('mtb') || msg.includes('trilha')) bikeType = 'mtb';
            if (msg.includes('passeio') || msg.includes('urbana')) bikeType = 'passeio';

            if (bikeType && database[bikeType]) {
                let productMessage = botMessages.bikeListHeader(bikeType);
                database[bikeType].forEach(bike => {
                    productMessage += botMessages.bikeListItem(bike);
                });
                productMessage += botMessages.bikeListFooter;
                enviarTexto(userNumber, productMessage);
                userStates[userNumber] = { state: 'AWAITING_CHOICE' };
            } else {
                enviarTexto(userNumber, botMessages.invalidBikeType);
            }
            break;

        case 'AWAITING_PART_TYPE':
            enviarTexto(userNumber, botMessages.searchPart(userMessage));
            userStates[userNumber] = { state: 'AWAITING_CHOICE' };
            break;

        case 'AWAITING_SERVICE_TYPE':
            let serviceType = null;
            if (msg.includes('revis√£o')) serviceType = 'revisao';
            if (msg.includes('manuten√ß√£o')) serviceType = 'manutencao';

            if (serviceType) {
                const availableDays = Object.keys(database.servicos[serviceType]).join(', ');
                let resposta = botMessages.listAvailableDays(serviceType, availableDays);
                enviarTexto(userNumber, resposta);
                userStates[userNumber] = { state: 'AWAITING_DAY_CHOICE', service: serviceType };
            } else {
                enviarTexto(userNumber, botMessages.invalidServiceType);
            }
            break;
            
        case 'AWAITING_DAY_CHOICE':
            const day = msg.split(' ')[0].replace('√ß', 'c').replace('√°', 'a');
            const service = userStates[userNumber].service;

            if (service && database.servicos[service] && database.servicos[service][day]) {
                const availableTimes = database.servicos[service][day].join(' / ');
                let resposta = botMessages.listAvailableTimes(day, service, availableTimes);
                enviarTexto(userNumber, resposta);
                userStates[userNumber] = { state: 'AWAITING_TIME_CHOICE', service: service, day: day };
            } else {
                enviarTexto(userNumber, botMessages.invalidDay);
            }
            break;
            
        case 'AWAITING_TIME_CHOICE':
             const time = msg.replace(':', 'h');
             const chosenService = userStates[userNumber].service;
             const chosenDay = userStates[userNumber].day;

             if (chosenService && chosenDay && database.servicos[chosenService][chosenDay].some(t => time.includes(t.replace(':', 'h')))) {
                const finalTime = database.servicos[chosenService][chosenDay].find(t => time.includes(t.replace(':', 'h')));
                const saved = await salvarAgendamento(userNumber, chosenService, chosenDay, finalTime);
                let resposta = '';
                if (saved) {
                    resposta = botMessages.bookingSuccessRegistered(chosenService, chosenDay, finalTime);
                } else {
                    resposta = botMessages.bookingSuccessUnregistered(chosenService, chosenDay, finalTime);
                }
                enviarTexto(userNumber, resposta);
                delete userStates[userNumber];
                setTimeout(() => {
                    enviarMenuPrincipalComoLista(userNumber);
                }, 3000);
             } else {
                 enviarTexto(userNumber, botMessages.invalidTime);
             }
             break;

        default:
            console.log(`Estado desconhecido: ${currentState}. Reiniciando fluxo.`);
            delete userStates[userNumber];
            enviarMenuPrincipalComoLista(userNumber);
            break;
    }
}

function enviarMenuPrincipalComoLista(userNumber) {
    const textoBoasVindas = botMessages.mainMenuHeader;
    
    const menuItens = [
        { id: "menu_produtos", title: "Ver Produtos üõçÔ∏è" },
        { id: "menu_agendar", title: "Agendar Manuten√ß√£o ‚öôÔ∏è" },
        { id: "menu_atendente", title: "Falar com Atendente üë®‚Äçüîß" },
        { id: "menu_endereco", title: "Endere√ßo e Hor√°rio üïí" }
    ];
    
    userStates[userNumber] = { state: 'AWAITING_CHOICE' };
    console.log(`[${userNumber}] Estado atualizado para: AWAITING_CHOICE`);
    enviarLista(userNumber, textoBoasVindas, "Menu Principal", menuItens);
}

// --- FUN√á√ïES DE ENVIO DE MENSAGEM ---
async function enviarPayloadGenerico(payload) {
    const recipientId = payload.to;
    console.log(`--- TENTANDO ENVIAR MENSAGEM PARA ${recipientId} ---`);
    const url = `https://graph.facebook.com/v19.0/${PHONE_NUMBER_ID}/messages`;
    const headers = {
        "Authorization": `Bearer ${META_ACCESS_TOKEN}`,
        "Content-Type": "application/json"
    };
    
    try {
        await axios.post(url, payload, { headers: headers });
        console.log(`--- MENSAGEM ENVIADA COM SUCESSO PARA ${recipientId} ---`);
    } catch (error) {
        console.error('--- ERRO AO ENVIAR MENSAGEM PELA API DA META ---');
        console.error('Payload de envio:', JSON.stringify(payload, null, 2));
        console.error(error.response ? JSON.stringify(error.response.data, null, 2) : error.message);
    }
}

async function enviarTexto(recipientId, text) {
    const payload = {
        messaging_product: "whatsapp",
        to: recipientId,
        type: "text",
        text: {
            body: text
        }
    };
    await enviarPayloadGenerico(payload);
}

async function enviarLista(recipientId, bodyText, buttonText, items) {
    const payload = {
        messaging_product: "whatsapp",
        to: recipientId,
        type: "interactive",
        interactive: {
            type: "list",
            body: {
                text: bodyText
            },
            action: {
                button: buttonText,
                sections: [
                    {
                        title: "Op√ß√µes Dispon√≠veis",
                        rows: items.map(item => ({
                            id: item.id,
                            title: item.title,
                        }))
                    }
                ]
            }
        }
    };
    await enviarPayloadGenerico(payload);
}

// --- OUVINTE DO FIRESTORE ---
function iniciarOuvinteDeAtendimentos() {
    const query = db.collection('atendimentos').where('status', '==', 'resolvido');

    query.onSnapshot(snapshot => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'modified') {
                const atendimento = change.doc.data();
                const userNumber = atendimento.cliente_id;
                
                if (userStates[userNumber] && userStates[userNumber].state === 'HUMAN_HANDOVER') {
                    console.log(`[${userNumber}] Atendimento encerrado pelo painel. Reativando bot.`);
                    delete userStates[userNumber];
                }
            }
        });
    }, err => {
        console.error("Erro no ouvinte do Firestore:", err);
    });
}


// Inicia o servidor
app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
    iniciarOuvinteDeAtendimentos();
    console.log("Ouvinte de atendimentos do Firestore iniciado com sucesso.");
});