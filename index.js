// Importa as bibliotecas que instalamos
const express = require('express');
const axios = require('axios');
require('dotenv').config(); // Carrega as vari√°veis de ambiente do arquivo .env

const app = express();
app.use(express.json()); // Permite que o express entenda o JSON enviado pela Meta

// --- INFORMA√á√ïES DE CONFIGURA√á√ÉO ---
// Buscando as vari√°veis do arquivo .env ou do ambiente do Render
const META_ACCESS_TOKEN = process.env.META_ACCESS_TOKEN;
const VERIFY_TOKEN = process.env.VERIFY_TOKEN;
const PHONE_NUMBER_ID = process.env.PHONE_NUMBER_ID;

// Define a porta em que o servidor vai rodar
const PORT = process.env.PORT || 3000;

// --- MEM√ìRIA E BASE DE DADOS ---

// Objeto para armazenar o estado da conversa de cada usu√°rio
const userStates = {};

// Simula√ß√£o de uma base de dados de produtos
const database = {
    "estrada": [
        { nome: "Caloi Strada Racing", preco: "R$ 7.500,00" },
        { nome: "Specialized Allez", preco: "R$ 9.200,00" }
    ],
    "mtb": [
        { nome: "Trek Marlin 5", preco: "R$ 4.800,00" },
        { nome: "Oggi Big Wheel 7.2", preco: "R$ 5.500,00" }
    ],
    "passeio": [
        { nome: "Caloi Urbam", preco: "R$ 2.100,00" },
        { nome: "Sense Move", preco: "R$ 2.350,00" }
    ]
};

// Rota principal para testar se o servidor est√° no ar
app.get('/', (req, res) => {
    res.send('Chatbot da Loja de Bicicletas est√° no ar!');
});

// Rota do Webhook (GET para verifica√ß√£o, POST para receber mensagens)
app.all('/webhook', (req, res) => {
    if (req.method === 'GET') {
        console.log('--- Recebida requisi√ß√£o de VERIFICA√á√ÉO do Webhook ---');
        // Processo de verifica√ß√£o da Meta
        if (req.query['hub.verify_token'] === VERIFY_TOKEN) {
            console.log('Token de verifica√ß√£o CORRETO.');
            return res.send(req.query['hub.challenge']);
        }
        console.error('Token de verifica√ß√£o INCORRETO.');
        return res.status(403).send('Erro de verifica√ß√£o');
    }

    if (req.method === 'POST') {
        console.log('--- NOVO EVENTO DO WEBHOOK RECEBIDO (POST) ---');
        console.log('Dados recebidos:', JSON.stringify(req.body, null, 2));
        
        // Processa as mensagens recebidas do WhatsApp
        const data = req.body;
        try {
            // Garante que a estrutura recebida √© de uma mensagem do WhatsApp
            if (data.object === 'whatsapp_business_account' && data.entry?.[0]?.changes?.[0]?.value?.messages?.[0]) {
                const messageData = data.entry[0].changes[0].value.messages[0];
                const fromNumber = messageData.from;

                // Lida tanto com mensagens de texto quanto com cliques em bot√µes
                let messageBody = '';
                if (messageData.type === 'text') {
                    messageBody = messageData.text.body;
                } else if (messageData.type === 'interactive' && messageData.interactive.type === 'button_reply') {
                    messageBody = messageData.interactive.button_reply.title;
                }

                if (messageBody) {
                    console.log(`Mensagem de [${fromNumber}] para nosso sistema: "${messageBody}"`);
                    // --- AQUI ENTRA A L√ìGICA DO SEU FLUXO ---
                    processarMensagem(fromNumber, messageBody);
                } else {
                     console.log('Tipo de mensagem interativa n√£o suportada (ex: lista). Ignorando.');
                }
                
            } else {
                console.log('Evento recebido n√£o √© uma mensagem do WhatsApp. Ignorando.');
            }

        } catch (error) {
            console.error('--- ERRO AO PROCESSAR DADOS DO WEBHOOK ---', error);
        }
        
        return res.status(200).send('OK');
    }
});

// Fun√ß√£o principal que gerencia o fluxo da conversa (ATUALIZADA)
function processarMensagem(userNumber, userMessage) {
    const msg = userMessage.toLowerCase().trim();

    // Obt√©m o estado atual do usu√°rio ou define como 'NEW_USER' se for a primeira vez
    const currentState = userStates[userNumber]?.state || 'NEW_USER';
    console.log(`[${userNumber}] Estado Atual: ${currentState}`);
    console.log(`[${userNumber}] Mensagem Recebida: ${msg}`);

    // Se a qualquer momento o usu√°rio digitar 'menu', 'voltar' ou 'cancelar', reinicia o fluxo
    if (["menu", "voltar", "cancelar"].includes(msg)) {
        userStates[userNumber] = { state: 'AWAITING_CHOICE' }; // Volta ao estado de aguardar escolha
        enviarMenuPrincipal(userNumber);
        return;
    }
    
    // L√≥gica baseada no estado atual
    switch (currentState) {
        case 'NEW_USER':
            // Envia a mensagem de boas-vindas especial e depois o menu
            const welcomeMessage = "Ol√°! üëã Bem-vindo(a) √† *Rota Ciclo*!\n\nEstamos inaugurando nosso novo canal de atendimento autom√°tico para te ajudar de forma mais r√°pida e pr√°tica. Por aqui, voc√™ j√° consegue resolver muita coisa!";
            enviarTexto(userNumber, welcomeMessage);
            // Espera um pouquinho para as mensagens n√£o chegarem coladas
            setTimeout(() => {
                enviarMenuPrincipal(userNumber);
            }, 1500); // 1.5 segundos
            break;

        case 'AWAITING_CHOICE':
            // Ap√≥s receber o menu, o bot aguarda uma escolha
            if (msg.startsWith("comprar bicicleta")) {
                console.log('Condi√ß√£o atendida: Op√ß√£o Comprar Bicicleta.');
                const resposta = "√ìtima escolha! üö¥ Temos bicicletas para:\n\n- Estrada\n- MTB (Trilha)\n- Passeio\n\nüëâ Me diga qual tipo voc√™ procura e j√° envio algumas op√ß√µes dispon√≠veis.";
                enviarTexto(userNumber, resposta);
                userStates[userNumber] = { state: 'AWAITING_BIKE_TYPE' }; // Atualiza o estado
            } else if (msg.startsWith("pe√ßas e acess√≥rios")) {
                console.log('Condi√ß√£o atendida: Op√ß√£o Pe√ßas e Acess√≥rios.');
                const resposta = "Legal! Temos c√¢maras, pneus, capacetes, luvas, roupas e muito mais üö¥.\n\nüëâ Digite o que voc√™ procura, que j√° te mostro op√ß√µes dispon√≠veis.";
                enviarTexto(userNumber, resposta);
                userStates[userNumber] = { state: 'AWAITING_PART_TYPE' }; // Atualiza o estado
            } else if (msg.startsWith("endere√ßo e hor√°rio")) {
                console.log('Condi√ß√£o atendida: Op√ß√£o Endere√ßo e Hor√°rio.');
                const resposta = "üìç *Endere√ßo:* Rua X, n¬∫ Y, Bairro Z\nüïí *Hor√°rio:* Segunda a Sexta ‚Äì 9h √†s 18h | S√°bado ‚Äì 9h √†s 13h\nüìû *Telefone:* (xx) xxxx-xxxx\n\nPosso te ajudar com algo mais?";
                enviarTexto(userNumber, resposta);
                userStates[userNumber] = { state: 'AWAITING_CHOICE' }; // Mant√©m no menu principal
            } else {
                console.log('Condi√ß√£o atendida: Op√ß√£o inv√°lida.');
                enviarTexto(userNumber, "Op√ß√£o inv√°lida. Por favor, clique em um dos bot√µes do menu.");
                enviarMenuPrincipal(userNumber); // Reenvia o menu
            }
            break;

        case 'AWAITING_BIKE_TYPE':
            let bikeType = null;
            if (msg.includes('estrada')) bikeType = 'estrada';
            if (msg.includes('mtb') || msg.includes('trilha')) bikeType = 'mtb';
            if (msg.includes('passeio') || msg.includes('urbana')) bikeType = 'passeio';

            if (bikeType && database[bikeType]) {
                let productMessage = `Aqui est√£o as op√ß√µes para bicicletas de *${bikeType.toUpperCase()}*:\n\n`;
                database[bikeType].forEach(bike => {
                    productMessage += `üö≤ *${bike.nome}*\n   Pre√ßo: ${bike.preco}\n\n`;
                });
                productMessage += "Gostou de alguma? Me diga o nome que te dou mais detalhes. Ou digite 'menu' para voltar.";
                enviarTexto(userNumber, productMessage);
                userStates[userNumber] = { state: 'AWAITING_CHOICE' }; // Volta ao menu
                
            } else {
                enviarTexto(userNumber, "N√£o entendi o tipo de bicicleta. Por favor, diga 'Estrada', 'MTB' ou 'Passeio'.");
                // Mant√©m o estado como AWAITING_BIKE_TYPE para nova tentativa
            }
            break;

        case 'AWAITING_PART_TYPE':
            // L√≥gica para pe√ßas pode ser adicionada aqui no futuro
            enviarTexto(userNumber, `Ok, buscando por "${userMessage}"... (Esta funcionalidade ser√° implementada em breve!)\n\nDigite 'menu' para voltar.`);
            userStates[userNumber] = { state: 'AWAITING_CHOICE' }; // Volta ao menu
            break;

        default:
            // Caso o estado seja desconhecido, reinicia
            console.log(`Estado desconhecido: ${currentState}. Reiniciando fluxo.`);
            delete userStates[userNumber];
            enviarMenuPrincipal(userNumber);
            break;
    }
}

// Fun√ß√£o de menu principal atualizada para definir o estado do usu√°rio
function enviarMenuPrincipal(userNumber) {
    const textoBoasVindas = "Ol√° üö¥, tudo bem?\n\nAqui √© a Loja *Rota Ciclo*! Obrigado pelo seu contato üôå\n\nEscolha uma op√ß√£o para facilitar seu atendimento:";
    
    const botoesDoMenu = [
        "Comprar bicicleta üö≤",
        "Pe√ßas e acess√≥rios üõ†Ô∏è",
        "Endere√ßo e Hor√°rio üïí"
    ];
    
    // Define o estado do usu√°rio para 'aguardando escolha' ap√≥s enviar o menu
    userStates[userNumber] = { state: 'AWAITING_CHOICE' };
    console.log(`[${userNumber}] Estado atualizado para: AWAITING_CHOICE`);

    enviarBotoes(userNumber, textoBoasVindas, botoesDoMenu);
}


// --- FUN√á√ïES DE ENVIO DE MENSAGEM ---

// Fun√ß√£o para enviar mensagens de texto via API da Meta usando Axios
async function enviarTexto(recipientId, text) {
    console.log(`--- TENTANDO ENVIAR RESPOSTA PARA ${recipientId} ---`);
    const url = `https://graph.facebook.com/v19.0/${PHONE_NUMBER_ID}/messages`;
    const headers = {
        "Authorization": `Bearer ${META_ACCESS_TOKEN}`,
        "Content-Type": "application/json"
    };
    const payload = {
        messaging_product: "whatsapp",
        to: recipientId,
        type: "text",
        text: {
            body: text
        }
    };
    console.log('Payload de envio:', JSON.stringify(payload, null, 2));

    try {
        await axios.post(url, payload, { headers: headers });
        console.log(`--- MENSAGEM ENVIADA COM SUCESSO PARA ${recipientId} ---`);
    } catch (error) {
        console.error('--- ERRO AO ENVIAR MENSAGEM PELA API DA META ---');
        console.error(error.response ? JSON.stringify(error.response.data, null, 2) : error.message);
    }
}

// Fun√ß√£o para enviar mensagens com BOT√ïES
async function enviarBotoes(recipientId, text, buttons) {
    console.log(`--- TENTANDO ENVIAR BOT√ïES PARA ${recipientId} ---`);
    const url = `https://graph.facebook.com/v19.0/${PHONE_NUMBER_ID}/messages`;
    const headers = {
        "Authorization": `Bearer ${META_ACCESS_TOKEN}`,
        "Content-Type": "application/json"
    };
    const payload = {
        messaging_product: "whatsapp",
        to: recipientId,
        type: "interactive",
        interactive: {
            type: "button",
            body: {
                text: text
            },
            action: {
                buttons: buttons.map((btn, index) => ({
                    type: "reply",
                    reply: {
                        id: `btn_${index + 1}`,
                        title: btn
                    }
                }))
            }
        }
    };
    console.log('Payload de envio:', JSON.stringify(payload, null, 2));

    try {
        await axios.post(url, payload, { headers: headers });
        console.log(`--- BOT√ïES ENVIADOS COM SUCESSO PARA ${recipientId} ---`);
    } catch (error) {
        console.error('--- ERRO AO ENVIAR BOT√ïES PELA API DA META ---');
        console.error(error.response ? JSON.stringify(error.response.data, null, 2) : error.message);
    }
}


// Inicia o servidor
app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
});